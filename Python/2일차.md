# 컨테이너
- 분류
  - 시퀀스형 : 순서가 있는 데이터(orderd)
    1. 리스트(List) 
    2. 튜플(Tuple)
    3. 레인지(Range)
    4. 문자형(String)
    5. 바이너리(Binary)
  - 비 시퀀스형 : 순서가 없는 데이터(unordered)
    1. 세트(Set)
    2. 딕셔너리(Dictionary)

## 1. 시퀀스형 컨테이너
### 1.1 리스트
- 생성방법 : 대괄호`[]` 및 `list()`
```
ex) locations = ['서울','부산','대전','대구','광주']
    => ['서울', '부산', '대전', '대구', '광주']
```
- 접근과 수정방법
  - 원하는 위치의 인덱스를 통해 할당`=`연산자로 수정 가능.
```
ex)
numbers = [1, 2, 3, 4, 5]

# 접근
numbers[2]

# 수정
numbers[2] = 30

# 추가
numbers.append(6)
print(numbers)

# 6 <-> 30 위치 바꾸기
numbers[5], numbers[2] = numbers[2], numbers[5]
print(numbers)

# 삭제(마지막 요소 삭제)
numbers.pop()
print(numbers)
```

### 1.2 튜플(Tuple)
- 생성방법 : `()` 로 묶어서 표현.
```
ex)
tuple = 2, 4, 10
print(tuple)
=> (2, 4, 10)
``` 
- 생성 주의 사항
  1. 단일 항목의 경우
     - 하나의 항목으로 구성된 튜플은 생성 시 값 뒤에 쉼표를 붙여야 함.
     ```
     ex)
     a = (1, )
     print(a)
     => (1,)
     ```  
  2. 복수 항목의 경우
     - 생성 시 마지막 값 뒤에 쉼표를 생략할 수 있음.   
   
- 접근과 수정방법
  - 수정이 불가능함.
```
ex)
numbers = (1, 2, 3)

# 접근 O
numbers[1]

# 수정 x
numbers[1] = 20
=> TypeError: 'tuple' object does not support item assignment
``` 

### 1.3 레인지(Range)
- 생성방법
  1. 기본형 : range(n) => 0부터 n-1까지의 값을 가짐
   ```
   ex)
   list(range(10))
   => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   ```
  2. 범위 지정 : range(n, m) => n부터 m-1까지 값을 가짐
   ```
   ex)
   list(range(4,9))
   => [4, 5, 6, 7, 8]
   ```
  3. 범위 및 스텝 지정 : range(n, m, s) => n부터 m-1까지 +s만큼 증가한다
   ```
   ex)
   list(range(2, 11, 2))
   => [2, 4, 6, 8, 10]

   list(range(9, 0, -2))
   => [9, 7, 5, 3, 1]
   ```
- 접근과 수정방법
  - 수정이 불가능함.
  ```
  ex)
  r = range(10)

  # 접근 O
  print(r[4])

  # 수정 X
  r[4] = 1
  => 'range' object does not support item assignment
  ```

### 1.4 패킹, 언패킹 연산자
모든 시퀀스형은 패킹/언패킹 연산자 `*`룰 사용하여 객체의 패킹 또는 언패킹이 가능하다.
- 패킹
  - 좌변에 위치해야함.
  - 우변의 객체 수가 좌변의 변수보다 많을 경우 객체를 순서대로 대입.
  - 나머지 항목들을 모두 연산자(`*`) 표시된 변수에 리스트로 대입.
  ```
  ex)
  x, *y = 1, 2, 3, 4, 5
  print(x, y)
  => 1 [2, 3, 4, 5]
  ```
- 언패킹
  - 언패킹의 경우, 튜플 형태로 대입.
  ```
  ex)
  numbers = [1, 2, 3]
      def multiply(x, y, z):
      return x * y * z
  multiply(*numbers)
  => 6
  ```
- 패킹/언패킹 연산자 주의사항
  - 연산자가 곱셈을 의미하는지, 패킹/언패킹 연산자인지 구분하여야함.

## 2. 비 시퀀스형 컨테이너
### 2.1 세트(Set)
set은 수학에서의 집합과 동일하게 처리.   
set은 중복된 값이 있을 수 없음.
- 생성방법
  - 중괄호 `{}` 를 통해 만들며, 순서가 없고 중복된 값이 없음
- 활용 가능 연산자
  - 차집합 : `-`
    ```
    ex)
    s1 = {1, 2, 3}
    s2 = {3, 4, 5}

    s1 - s2
    => {1, 2}
    ```
  - 합집합 : `|`
    ```
    ex)
    s1 = {1, 2, 3}
    s2 = {3, 4, 5}

    s1 | s2
    => {1, 2, 3, 4, 5}
    ```
  - 교집합 : `&`
    ```
    ex)
    s1 = {1, 2, 3}
    s2 = {3, 4, 5}

    s1 & s2
    => {3}
    ```
  - 접근과 수정방법
    ```
    s = {1, 2, 3, 2, 1}

    # 접근(인덱스가 없어서 단일 요소 접근 불가능)

    # 추가
    s.add(4)
    print(s)
    => {1, 2, 3, 4}

    # 삭제
    s.remove(2)
    print(s)
    => {1, 3, 4}
    ```
### 2.2 딕셔너리(Dictionary)
dictionary는 `key`와 `value`가 쌍으로 이뤄져있음.
- 생성방법
  - `{}`를 통해 만들며, `dict()`로 만들 수 있음.
  - 순서를 보장하지 않음.
  - value는 list, dictionary를 포함한 모든 것이 가능.
  - key는 변경 불가능(immutable)한 데이터만 가능.
  - dictionary에 중복된 key는 존재할 수 없음.
- 활용 함수(메소드)
  - .keys()
    - key를 확인 해볼 수 있음.
      ```
      ex)
      phone_book = {'서울':'02', '경기':'031', '인천':'032', '대전':'042', '광주':'062'}

      phone_book.keys()
      => dict_keys(['서울', '경기', '인천', '대전', '광주'])
      ```
  - .values()
    - value를 확인 해볼 수 있음.
    ```
    ex)
    phone_book = {'서울':'02', '경기':'031', '인천':'032', '대전':'042', '광주':'062'}

    phone_book.values()
    => dict_values(['02', '031', '032', '042', '062'])
    ```
  - .items()
    - key와 value 목록을 확인 해 볼 수 있음.
      ```
      ex)
      phone_book = {'서울':'02', '경기':'031', '인천':'032', '대전':'042', '광주':'062'}

      phone_book.items()
      => dict_items([('서울', '02'), ('경기', '031'), ('인천', '032'), ('대전', '042'), ('광주', '062')])
      ```
- 접근과 수정방법
  - 할당식을 통해 key-value 추가 가능
  - 할당식을 통해 value 수정 가능
```
ex)
# dict는 key 중복 안됨. value는 됨

phone_book = {
    '서울':'02',
    '경기':'031',
    '인천':'032',
    '대전':'042',
    '광주':'062', # 컨테이너 자료형을 여러줄에 쓸 경우, 반드시 Trailing Comma 적을것!!!!(중요)
}

# 접근 (key 없으면 error남)
print(phone_book['서울'])

# 변경 (key가 이미 존재한다면 => 수정)
phone_book['서울'] = '022'
print(phone_book)
=> {'서울': '022', '경기': '031', '인천': '032', '대전': '042', '광주': '062'}

#(key가 존재하지 않는 다면 => key-velue 추가)
phone_book['평양'] = '냉면'
print(phone_book)
=> {'서울': '022', '경기': '031', '인천': '032', '대전': '042', '광주': '062', '평양': '냉면'}
```

## 3. 형변환
![형변환](https://user-images.githubusercontent.com/18046097/61180466-a6a67780-a651-11e9-8c0a-adb9e1ee04de.png)

## 4. 시퀀스형 연산자
### 4.1 산술 연산자 (+)
시퀀스를 연결(concatenation)할 수 있음. 더하기가 아니고 연결의 의미. range에는 사용불가
```
ex)
[1, 2] + ['a']
=> [1, 2, 'a']

(1, 2) + ('a',)
=> (1, 2, 'a')

'12' + 'a'
=> '12a'
```
### 4.2 반복 연산자 (*)
시퀀스를 반복할 수 있음. range에는 사용불가.
```
ex)
[0] * 8
=> [0, 0, 0, 0, 0, 0, 0, 0]

(1, 2) * 3
=> (1, 2, 1, 2, 1, 2)

'hi' * 3
=> 'hihihi'
```

## 5. 인덱싱/슬라이싱
### 5.1 인덱싱
시퀀스의 특정 인덱스 값에 접근 할 수 있음.
```
ex)
[1, 2, 3][2]
=> 3

(1, 2, 3)[0]
=> 1

range(1, 10, 2)[3]
=> 7

'abc'[0]
=> 'a'
```

### 5.2 슬라이싱
시퀀스를 특정 단위로 슬라이싱 할 수 있음.
```
ex)
print([1, 2, 3, 4][1:4])
print((1, 2, 3)[:2])
print(range(10)[5:8])
print('abcd'[2:4])

=> [2, 3, 4]
(1, 2)
range(5, 8)
cd
```